/* autogenerated by Processing revision 1293 on 2024-03-06 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class JumpmapGenerator extends PApplet {




PGraphics screenshot, selectLayer, jumpmap, ui, background;
PImage userBackground;
Thread bgDraw,uiDraw;
ExecutorService jmDraw = Executors.newCachedThreadPool();
StarMap starmap;
UImanager uim = new UImanager();
boolean stateChanged = false;
boolean jumpMapPrepared = false;
boolean uiPrepared = false;
boolean mouseHold = false;
boolean fileSelected = false;
String lastKey = "z";

enum editMode {
    SELECT,
    DELETE,
    ADD
}

enum editType {
    STAR,
    CONNECTION
}

editMode mode = editMode.SELECT;
editType type = editType.STAR;
UStar selectedStar;
Connection selectedConn;
UIVertSlider sizeSlider;
Renderable selected;

//Fiddly Bits
//Change these to affect the generated image.
float freq1 = 0.003f; //Layer 1 Noise Frequency
float freq2 = 0.01f; // Layer 2 Noise Frequency
int minGap = 30; //min number of pixels between each star.
int starMax = 10; //max size of stars
int starMin = 8; //min size of stars
float starWeight = 3; //influences the number of stars generated, higher is more.
float distanceMod = 0.5f; //influences how agressive it cuts off lanes because of the distance between stars.
int buffer = 30; //how far away from the sides of the window stars can begin spawning.
int maxJumps = 6; //maximum jump connections a star can have.
float jumpDistance = 80; //how far jumplanes can connect
float jumplaneThickness = 3; //how thick (visiaully) each jumplane is

public void setup() {
    /* size commented out by preprocessor */;
    background(0);
    frameRate(24);
    starmap = new StarMap();
    screenshot = createGraphics(900,900);
    background = createGraphics(1000, 1000);
    selectLayer = createGraphics(900,900);
    jumpmap = createGraphics(900, 900);
    ui = createGraphics(1000, 1000);
    bgDraw = new Thread(() -> {prepareBackground();});
    jmDraw.execute(() -> {prepareJumpmap();});
    uiDraw = new Thread(() -> {prepareUI();});
    bgDraw.start();
    uiDraw.start();
    selectImage();
}

public void draw() {
    background(0);
    renderChanges();
    connectionAdd();
    if (fileSelected) {
        image(userBackground,0,0);
    }
    image(background, 0, 0);
    image(selectLayer, 0, 0);
    image(jumpmap, 0, 0);
    image(ui, 0, 0);
}

public void selectImage() {
  selectInput("Select a Background:", "fileSelected");
}
public void fileSelected(File selection) {
  if (selection != null) {
    userBackground = loadImage(selection.getAbsolutePath());
    userBackground.resize(900,900);
    fileSelected = true;
  }
}

public void prepareUI() {
    PShape button = createShape(GROUP);
    PShape base = createShape(RECT, 0,0,150,55);
    base.setFill(color(100,100,100));
    base.setStroke(false);
    PShape base2 = createShape(RECT, 5,5,140,45);
    base2.setFill(color(150,150,150));
    base2.setStroke(color(255,0,0));
    button.addChild(base);
    button.addChild(base2);
    PShape button2 = createShape(GROUP);
    PShape base3 = createShape(RECT, 0,0,210,55);
    base3.setFill(color(100,100,100));
    base3.setStroke(false);
    PShape base4 = createShape(RECT, 5,5,200,45);
    base4.setFill(color(150,150,150));
    base4.setStroke(color(255,0,0));
    button2.addChild(base3);
    button2.addChild(base4);
    uim.register(new SelectButton(new PVector(10,910),button,150,55,color(0),50,new PVector(10,45)));
    uim.register(new AddButton(new PVector(170,910),button,150,55,color(0),50,new PVector(35,45)));
    uim.register(new DeleteButton(new PVector(330,910),button,150,55,color(0),50,new PVector(10,45)));
    uim.register(new ClearButton(new PVector(600,910),button,150,55,color(0),50,new PVector(10,45)));
    uim.register(new GenButton(new PVector(760,910),button2,210,55,color(0),50,new PVector(10,45)));
    UIVertSlider vert = new UIVertSlider(40,20,color(100,100,100),new PVector(950,20),new PVector(950,500),color(100,100,100),4,0,20,8);
    uim.register(vert);
    sizeSlider = vert;

    println("UI Prepared!");
    uiPrepared = true;
}

public void prepareJumpmap() {
    jumpmap.beginDraw();
    float[] map = new float[jumpmap.width*jumpmap.height];
    float mapmax = 0;
    float mapmin = 1;
    jumpmap.loadPixels();
    for(int y = 0; y < jumpmap.height; y++) {
        //precomputing all y values to help save on render time
        float prey1 = y*freq1;
        float prey2 = y*freq2;
        int backy = y*jumpmap.width;
        for (int x = 0; x < jumpmap.width; x++) {
            //generating base noise values
            float n = noise(x*freq1, prey1,20);
            float d = noise(x*freq2, prey2,30);
            
            //compound value (weighted towards lower detail noise) to give texture
            float comp = n*0.7f+d*0.3f;
            comp += 1.0f;
            comp *= 0.5f; //avoiding division

            map[backy+x] = comp; //adding raw values to a map for later reference
            if (comp > mapmax) {
                mapmax = comp;
            }
            if (comp < mapmin) {
                mapmin = comp;
            }
        }
    }

    for(int y = 0; y < jumpmap.height; y++) {
        if (y < buffer || y > jumpmap.height-buffer) {
          continue;
        }
        int backy = y*jumpmap.width;
        for (int x = 0; x < jumpmap.width; x++) {        
            if (x < buffer || x > jumpmap.width-buffer) {
              continue;
            }
            //exponential random function so stars are clustered around light points.
            float val = (float) Math.log(Math.random())/((float) -normalize(map[backy+x],mapmin,mapmax)*(starWeight*0.01f));
            if (val < 0.1f) {
                //testing if the generated star is too close to an existing one (as defined by minGap)
                //this is pretty slow, because it reduces this loop to O(N^3) but other approaches like GLSL compute shaders would be a bit too time intensive for me to work on right now.
                UStar nearest = starmap.nearestNeighbor(x,y);
                float dist = distance(x,nearest.posX(),y,nearest.posY());
                if (dist > minGap) {
                    int greenOff = (int) Math.round(Math.random() * (155 - 5) + 5);
                    int blueOff = (int) Math.round(Math.random() * (155 - 5) + 5);
                    int col = color(100,100+greenOff,100+blueOff);
                    int size = (int) Math.round(Math.random() * (starMax - starMin) + starMin);
                    fill(col);
                    noStroke();
                    PShape s = createShape(ELLIPSE,0,0,size,size);
                    PVector pos = new PVector(x,y);
                    UStar star = new UStar(pos,s,size);
                    starmap.add(star);
                }
            }
        }
    }

    for (int i = 0; i < starmap.size(); i++) {
        UStar s = starmap.retrieve(i);
        List<UStar> jumpRoutes = starmap.nearestNeighbors(s,maxJumps,new ArrayList<UStar>(),jumpDistance);
        int routes = jumpRoutes.size();
        for (int x = jumpRoutes.size()-1; x > 0; x--) {
            UStar routeStar = jumpRoutes.get(x);
            float dist = distance(s.posX(),routeStar.posX(),s.posY(),routeStar.posY());
            float val = (float) Math.log(Math.random())/((float) normalize(dist,0,jumpDistance)*(distanceMod*0.01f));
            if (routes <= 2) {
                break;
            }
            if (val < 0.1f) {
                jumpRoutes.remove(routeStar);
                routes--;
            }
        }
        for(UStar star : jumpRoutes) {
            starmap.addConnection(s,star);
        }

    }

    List<Connection> conn = starmap.getJumpLanes();
    for (Connection c : conn) {
        for (Connection cd : conn) {
            if (cd != c) {
                if (starmap.checkIntersect(c,cd)) {
                    if (c.dist() > cd.dist()) {
                        starmap.removeConnection(c);
                    } else {
                        starmap.removeConnection(cd);
                    }
                }
            }
        }
    }
    jumpmap.endDraw();
    jumpMapPrepared = true;
    println("Jumpmap Prepared!");
}
public void connectionAdd() {
    if (mode == editMode.ADD && type == editType.CONNECTION) {
        if (selectedStar != null) {
            ui.beginDraw();
            ui.stroke(255,255,255,150);
            ui.strokeWeight(Math.round(sizeSlider.getVal()));
            ui.line(selectedStar.posX(),selectedStar.posY(),mouseX,mouseY);
            ui.endDraw();
        }
    }
}
public void prepareBackground() {
    background.beginDraw();
    background.noStroke();
    background.fill(200);
    background.rect(0, 900, 1000, 100);
    background.rect(900, 0, 100, 1000);
    background.endDraw();

    println("Background Prepared!");
}

public void renderChanges() {
    if (jumpMapPrepared) {
        jumpmap.beginDraw();
        jumpmap.background(0,0,0,0);
        starmap.render(jumpmap);
        jumpmap.endDraw();
    }
    if (uiPrepared) {
        ui.beginDraw();
        ui.background(0,0,0,0);
        uim.render(ui);
        ui.endDraw();
    }
    if (selected != null) {
        selectLayer.beginDraw();
        selectLayer.background(0,0,0,0);
        selected.render(selectLayer);
        selectLayer.filter(BLUR,8);
        selectLayer.endDraw();
    }
}

public void mousePressed() {
    uim.registerClick(mouseX,mouseY);
    starmap.registerClick(mouseX,mouseY,jumplaneThickness);
    if (mode == editMode.ADD && (mouseButton == LEFT)) {
        int greenOff = (int) Math.round(Math.random() * (155 - 5) + 5);
        int blueOff = (int) Math.round(Math.random() * (155 - 5) + 5);
        int col = color(100,100+greenOff,100+blueOff);
        float size = Math.round(sizeSlider.getVal());
        PShape s = createShape(ELLIPSE,0,0,size,size);
        s.setFill(col);
        s.setStroke(false);
        starmap.add(new UStar(new PVector(mouseX,mouseY),s,size));
    } else {

    }
    mouseHold = true;
}

public void mouseReleased() {
    uim.registerRelease(mouseX,mouseY);
    starmap.registerRelease(mouseX,mouseY);
    mouseHold = false;
}

public void keyPressed() {
    if (key == CODED) {
        if (keyCode == SHIFT) {
            lastKey = "Shift";
        }
    }
    if (key == 27) {
        key = 0;
        selectedConn = null;
        selectedStar = null;
    }
    if (key == 's') {
        lastKey = "s";
        jumpmap.save("Jumpmap-Transparent.png");
    }
    if (lastKey.equals("Shift") || lastKey.equals("s")) {
        if (key == 's' || keyCode == SHIFT) {
            screenshot.beginDraw();
            if (fileSelected) {
                screenshot.image(userBackground,0,0);
            } else {
                background(0);
            }
            screenshot.image(jumpmap,0,0);
            screenshot.endDraw();
            screenshot.save("Jumpmap-Full.png");
        }
    }
}
public void mouseDragged(){
    uim.registerHold(mouseX,mouseY);
    starmap.registerHold(mouseX,mouseY);
}
public interface Renderable {
    public void render();
    public void render(PGraphics buffer);
}
public float normalize(float val, float min, float max) {
    return (val - min)/(max - min);
}

public float distance(float x1, float x2, float y1, float y2) {
    return (float) Math.sqrt(Math.pow(x2-x1,2)+Math.pow(y2-y1,2));
}

public float clamp(float val, float min, float max) {
    float temp;
    if (val < min) {
        temp = min;
    } else if (val > max) {
        temp = max;
    } else {
        temp = val;
    }
    return temp;
}

public float shunt(float val, float min, float max) {
    float temp;
    if (val > min) {
        temp = max;
    } else {
        temp = min;
    }
    return temp;
}

public boolean onSegment(PVector p, PVector q, PVector r) 
{ 
    if (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && 
        q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y)) 
    return true; 
  
    return false; 
} 
  

public float orientation(PVector p, PVector q, PVector r) 
{ 
    float val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y); 
    if (val == 0) return 0;
    return (val > 0)? 1: 2;
} 
   
public boolean doIntersect(PVector p1, PVector q1, PVector p2, PVector q2) 
{ 
    float o1 = orientation(p1, q1, p2); 
    float o2 = orientation(p1, q1, q2); 
    float o3 = orientation(p2, q2, p1); 
    float o4 = orientation(p2, q2, q1); 

    if (o1 != o2 && o3 != o4) return true; 
    if (o1 == 0 && onSegment(p1, p2, q1)) return true; 
    if (o2 == 0 && onSegment(p1, q2, q1)) return true; 
    if (o3 == 0 && onSegment(p2, p1, q2)) return true; 
    if (o4 == 0 && onSegment(p2, q1, q2)) return true; 
  
    return false;
} 
  public boolean isOnLine(PVector v0, PVector v1, PVector p, float w) {
    // Return minimum distance between line segment vw and point p
    PVector vp = new PVector();
    PVector line = PVector.sub(v1, v0);
    float l2 = line.magSq();  // i.e. |w-v|^2 -  avoid a sqrt
    if (l2 == 0.0f) {
      vp.set(v0);
      return false;
    }
    PVector pv0_line = PVector.sub(p, v0);
    float t = pv0_line.dot(line)/l2;
    pv0_line.normalize();
    vp.set(line);
    vp.mult(t);
    vp.add(v0);
    float d = PVector.dist(p, vp);
    if (t >= 0 && t <= 1 && d <= w)
      return true;
    else
      return false;
  }

public float vecDot(PVector v1, PVector v2) {
    float x = v1.x*v2.x;
    float y = v1.y*v2.y;
    return x+y;
}
public PVector vecAdd(PVector v1, PVector v2) {
    return new PVector(v1.x+v2.x,v1.y+v2.y);
}
public PVector vecSub(PVector v1, PVector v2) {
    return new PVector(v1.x-v2.x,v1.y-v2.y);
}
public PVector vecMulti(PVector v1, PVector v2) {
    return new PVector(v1.x*v2.x,v1.y*v2.y);
}
public PVector vecDiv(PVector v1, PVector v2) {
    return new PVector(v1.x/v2.x,v1.y/v2.y);
}
public PVector vecScalarAdd(PVector v, float s) {
    return new PVector(v.x+s,v.y+s);
}
public PVector vecScalarSub(PVector v, float s) {
    return new PVector(v.x-s,v.y-s);
}
public PVector vecScalarMulti(PVector v, float s) {
    return new PVector(v.x*s,v.y*s);
}
public PVector vecScalarDiv(PVector v, float s) {
    return new PVector(v.x/s,v.y/s);
}
public PVector vecPow (PVector v, float power) {
    return new PVector((float) Math.pow(v.x,power), (float) Math.pow(v.y,power));
}
class UStar extends UIBody{
    float radius;

    public UStar(PVector pos, PShape design, float radius) {
        super(pos,design,new Touchbox());
        this.radius = radius;
    }
    public UStar() {
        super(new PVector(0,0),createShape(),new Touchbox());
    }

    public float radius() {
        return radius;
    }

    @Override
    public boolean inBounds(float x, float y) {
        float u = distance(x,pos.x,y,pos.y);
        if (u < radius()/2) {return true;}
        return false;
    }  

    public void onClick(float x, float y) {
        held = true;
        if (mode == editMode.DELETE) {
            if (mousePressed && (mouseButton == LEFT)) {
                starmap.removeStar(this);
            }
        } else if (mode == editMode.SELECT) {
            if (mousePressed && (mouseButton == LEFT)) {
                selected = this;
            }
        } else if (mode == editMode.ADD) {
            if (mousePressed && (mouseButton == RIGHT)) {
                if (this != selectedStar && selectedStar != null) {
                    starmap.addConnection(this, selectedStar, color(255),Math.round(sizeSlider.getVal()));
                    selectedStar = null;
                    type = editType.STAR; 
                } else {
                    type = editType.CONNECTION; 
                    selectedStar = this;
                }
            }
        } 
    }
    public void onHold(float x, float y) {
        if (mode == editMode.SELECT && held) {
            if (mousePressed && (mouseButton == LEFT)) {
                this.pos = new PVector(x,y);
            }   
        }
    }
    public void onRelease(float x, float y) {
        held = false;
    }
}

class Connection implements Renderable{ 
    UStar pos1;
    UStar pos2;
    float dist;
    int col;
    float laneThickness;

    public Connection(UStar p1, UStar p2, int col, float laneThickness) {
        this.col = col;
        pos1 = p1;
        pos2 = p2;
        dist = distance(p1.posX(),p2.posX(),p1.posY(),p2.posY());
        this.laneThickness = laneThickness;
    }

    public UStar getFirstStar() {
        return pos1;
    } 
    public UStar getSecondStar() {
        return pos2;
    }

    public PVector getPos1() {
        PVector p1 = pos1.pos();
        PVector p2 = pos2.pos();
        float dx = p2.x-p1.x;
        float dy = p2.y-p1.y;
        float tv = abs(dx)+abs(dy);
        float radius = pos1.radius();
        float nx = normalize(dx,0,tv);
        float ny = normalize(dy,0,tv);
        PVector fin = new PVector(p1.x+nx,p1.y+ny);
        return fin;
    }
    public PVector getPos2() {
        PVector p1 = pos2.pos();
        PVector p2 = pos1.pos();
        float dx = p2.x-p1.x;
        float dy = p2.y-p1.y;
        float tv = abs(dx)+abs(dy);
        float radius = pos2.radius();
        float nx = normalize(dx,0,tv);
        float ny = normalize(dy,0,tv);
        PVector fin = new PVector(p1.x+nx,p1.y+ny);
        return fin;
    }
    public int col() {
        return col;
    }
    public float dist(){
        return dist;
    }
    public boolean match(UStar one, UStar two) {
        if (pos1 == one || pos2 == one) {
            if (pos1 == two || pos2 == two) {
                return true;
            }
        }
        return false;
    }

    public void onClick() {
        if (mode == editMode.DELETE) {
            if (mousePressed && (mouseButton == RIGHT)) {
                starmap.removeConnection(this);
            }
        }
        if (mode == editMode.SELECT) {
            if (mousePressed && (mouseButton == RIGHT)) {
                selected = this;
            }
        }
    }
    public boolean clicked(float x, float y, float w) {
        PVector A = pos1.pos();
        PVector B = pos2.pos();
        return isOnLine(A,B,new PVector(x,y),w);
    }

    public void render(PGraphics buffer) {
        buffer.stroke(col());
        buffer.strokeWeight(laneThickness);
        buffer.line(getPos1().x,getPos1().y,getPos2().x,getPos2().y);
    }
    public void render() {

    }
}

class StarMap {
    private List<UStar> starMap;
    private List<Connection> jump;

    public StarMap() {
        starMap = new CopyOnWriteArrayList<UStar>();
        jump = new CopyOnWriteArrayList<Connection>();
    }
    public StarMap(CopyOnWriteArrayList<UStar> list) {
        starMap = list;
        jump = new CopyOnWriteArrayList<Connection>();
    }
    public StarMap(CopyOnWriteArrayList<UStar> list, CopyOnWriteArrayList<Connection> conn) {
        starMap = list;
        jump = conn;
    }

    public UStar nearestNeighbor(int x, int y) {
        float closestDist = 99999999; //arbitrarily high, so its initialized, but always overwritten
        UStar neighbor = new UStar();
        for (int i = 0; i < starMap.size(); i++) {
            UStar ref = starMap.get(i);
            float dist = distance(x,ref.posX(),y,ref.posY());
            if (dist < closestDist) {
                closestDist = dist;
                neighbor = ref;
            }
        }
        return neighbor;
    }

    public List<UStar> nearestNeighbors(UStar star, float ammount, List<UStar> exclusion, float distanceLimit) {
        ArrayList<UStar> neighbor = new ArrayList<UStar>();
        for (int i = 0; i < starMap.size(); i++) {
            UStar ref = starMap.get(i);
            float dist = distance(star.posX(),ref.posX(),star.posY(),ref.posY());
            if (neighbor.size() == 0 && dist < distanceLimit) {
                if (!exclusion.contains(ref) && ref != star) {
                    neighbor.add(ref);
                }
            }
            for (int a = 0; a < neighbor.size(); a++) {
                UStar na = neighbor.get(a);
                float ndist = distance(star.posX(),na.posX(),star.posY(),na.posY());
                if (dist < ndist && dist < distanceLimit) {
                    if (!exclusion.contains(ref) && ref != star) {
                        if (neighbor.size() < ammount) {
                            neighbor.add(ref); 
                        } else {
                            UStar elim = new UStar();
                            float furDist = 0;
                            for (UStar n : neighbor) {
                                float fdist = distance(star.posX(),n.posX(),star.posY(),n.posY());
                                if (fdist > furDist) {
                                    furDist = fdist;
                                    elim = n;
                                }
                            }
                            neighbor.remove(elim);
                            neighbor.add(ref);
                        }
                    }
                }
            }
        }
        return neighbor;
    }
    public List<UStar> nearestNeighbors(UStar star, float ammount, List<UStar> exclusion) {
        return nearestNeighbors(star,ammount,exclusion,999999999);
    }
    public List<UStar> nearestNeighbors(UStar star, float ammount) {
        return nearestNeighbors(star,ammount,new ArrayList<UStar>());
    }
    public boolean jumpMatch(UStar one, UStar two) {
        for (Connection c : jump) {
            if (c.match(one,two)) {
                return true;
            }
        }
        return false;
    }
    public boolean checkIntersect(Connection one, Connection two) {
        PVector A = one.getPos1();
        PVector B = one.getPos2();
        PVector C = two.getPos1();
        PVector D = two.getPos2();
      return doIntersect(A,B,C,D);
    }

    public void addConnection(UStar one, UStar two) {
        addConnection(one, two, color(255),jumplaneThickness);
    }
    public void addConnection(UStar one, UStar two, int col, float thickness) {
        if (!jumpMatch(one,two)) {
            jump.add(new Connection(one, two, col,thickness));
        }
    }
    public void removeConnection(Connection c) {
        jump.remove(c);
        stateChanged = true;
    }

    public List<Connection> getJumpLanes() {
        return jump;
    }

    public void add(UStar star) {
        starMap.add(star);
    }

    public int size() {
        return starMap.size();
    }

    public void removeStar(UStar s) {
        for (Connection c : jump) {
            if (s == c.getFirstStar() || s == c.getSecondStar()) { 
                removeConnection(c);
            }
        }
        starMap.remove(s);
        stateChanged = true;
    }

    public UStar retrieve(int index) {
        return starMap.get(index);
    }

    public void registerClick(float x, float y, float width) {
        for (UStar ui : starMap) {
            if (ui.inBounds(x,y)) {
                ui.onClick(x,y);
            }
        }
        for (Connection conn : jump) {
            if (conn.clicked(x,y,width+0.5f)) {
                conn.onClick();
            }
        }
    }
    public void registerHold(float x, float y) {
        for (UStar ui : starMap) {
            ui.onHold(x,y);
        }
    }
    public void registerRelease(float x, float y) {
        for (UStar ui : starMap) {
            ui.onRelease(x,y);
        }
    }
    public void render(PGraphics buffer) {
        for (Connection c : jump) {
            c.render(buffer);
        }
        for (UStar s : starMap) {
            s.render(buffer);
        }
    }
    public void clear() {
        for (UStar star : starMap) {
            removeStar(star);
        }
    }
}


public class UImanager {
    private List<UIBody> components = new CopyOnWriteArrayList();

    public void render() {
        for (UIBody body : components) {
            body.render();
        }
    }

    public void render(PGraphics buffer) {
        for (UIBody body : components) {
            body.render(buffer);
        }
    }
    public void register(UIBody body) {
        components.add(body);
    }

    public void registerClick(float x, float y) {
        for (UIBody ui : components) {
            if (ui.inBounds(x,y)) {
                ui.onClick(x,y);
            }
        }
    }
    public void registerHold(float x, float y) {
        for (UIBody ui : components) {
            ui.onHold(x,y);
        }
    }
        public void registerRelease(float x, float y) {
        for (UIBody ui : components) {
            ui.onRelease(x,y);
        }
    }
}

public class Touchbox {
    public PVector pos;
    public PVector limit;
    private PVector difference;

    public Touchbox() {
        pos = new PVector(0,0);
        limit = new PVector(0,0);
        difference = new PVector(0,0);
    }
    public Touchbox(PVector pos, PVector limit) {
        this.pos = pos;
        this.limit = limit;
        difference = new PVector(limit.x-pos.x, limit.y-pos.y);
    }

    public void move(PVector newpos) {
        pos = newpos;
        limit = new PVector(newpos.x+difference.x,newpos.y+limit.y);
    }

    public boolean touched(float x, float y) {
        if (x >= pos.x && x <= limit.x && y >= pos.y && y <= limit.y) {
            return true;
        }
        return false;
    }

    @Override
    public String toString() {
        return "[Pos:[x:"+pos.x+",y:"+pos.y+"], Limit:[x:"+limit.x+",y:"+limit.y+"], Difference: [x:"+difference.x+" y:"+difference.y+"]]";
    }
}

public abstract class UIBody implements Renderable{
    protected PVector pos;
    protected PShape design;
    protected Touchbox touch;
    protected boolean enabled = true;
    protected boolean visible = true;
    protected boolean held = false;


    public UIBody(PVector pos, PShape design, Touchbox touch) {
        this.pos = pos;
        this.design = design;
        this.touch = touch;
    }
    //getters
    public PVector pos() {return pos;}
    public int posX() {return (int) pos.x;}
    public int posY() {return (int) pos.y;}
    public boolean getVisibility() {return visible;}
    public boolean getEnabled() {return enabled;}
    public boolean inBounds(float x, float y) {return touch.touched(x,y) && enabled && visible;}

    //setters
    public void setVisibility(boolean b) {visible = b;}
    public void setEnabled(boolean b) {enabled = b;}
    
    public abstract void onClick(float x, float y);
    public abstract void onHold(float x, float y);
    public abstract void onRelease(float x, float y);
    public void render() {
        if (visible) {
            shape(design, pos.x,pos.y);
        }
    }
    public void render(PGraphics buffer) {
        if (visible) {
            buffer.shape(design, pos.x,pos.y);
        }
    }
    @Override
    public String toString() {
      return "[ x:"+pos.x+"y:"+pos.y+" Touchbox:"+touch.toString()+"]";
    }
}

public abstract class UIButton extends UIBody {
    protected String text;
    protected PVector textpos;
    protected int textFill;
    protected float textSize;
    public UIButton(PVector pos, PShape design, float width, float height, String text, int textFill, float textSize, PVector textpos) {
        super(pos,design,new Touchbox(pos, new PVector(pos.x+width,pos.y+height)));
        this.text = text;
        this.textpos = textpos;
        this.textFill = textFill;
        this.textSize = textSize;
    }

    @Override
    public void render() {
        if (visible) {
            shape(design, pos.x,pos.y);
            fill(textFill);
            textSize(textSize);
            text(text,pos.x+textpos.x,pos.y+textpos.y);
        }
    }
    @Override
    public void render(PGraphics buffer) {
        if (visible) {
            buffer.shape(design, pos.x,pos.y);
            buffer.fill(textFill);
            buffer.textSize(textSize);
            buffer.text(text,pos.x+textpos.x,pos.y+textpos.y);
        }
    }
}

public class UIVertSlider extends UIBody {
    PVector trackPos1;
    PVector trackPos2;
    float trackThickness;
    float offsetx;
    float offsety;
    int trackColor;
    float minVal;
    float maxVal;
    float val;
    public UIVertSlider(float sliderWidth, float sliderwHeight,int sliderColor, PVector trackPos1, PVector trackPos2, int trackColor, float trackThickness, float minVal, float maxVal, float startingVal) {
        super(new PVector(0,0),createShape(GROUP),new Touchbox());
        PVector difference = vecSub(trackPos1,trackPos2);
        float norm = normalize(startingVal,minVal,maxVal);
        difference = vecScalarMulti(difference,norm*-1);
        PShape slide = createShape(RECT,0,0,sliderWidth,sliderwHeight);
        slide.setFill(sliderColor);
        slide.setStroke(false);
        this.design = slide;
        this.pos = vecAdd(trackPos1,vecSub(difference,new PVector(sliderWidth*0.5f,0)));
        this.touch = new Touchbox(new PVector(pos.x-sliderWidth*0.5f,pos.y-sliderwHeight*0.5f),new PVector(pos.x+sliderWidth*0.5f,pos.y+sliderwHeight*0.5f));
        this.trackPos1 = trackPos1;
        this.trackPos2 = trackPos2;
        this.trackThickness = trackThickness;
        this.trackColor = trackColor;
        this.minVal = minVal;
        this.maxVal = maxVal;
        this.val = startingVal;
        this.offsetx = sliderWidth*0.5f;
        this.offsety = sliderwHeight*0.5f;
    }

    public float getMinVal() {
        return minVal;
    }
    public float getMaxVal() {
        return maxVal;
    }
    public float getVal() {
        return val;
    }

    @Override
    public void render(PGraphics buffer) {
        if (visible) {
            buffer.stroke(trackColor);
            buffer.strokeWeight(trackThickness);
            buffer.line(trackPos1.x,trackPos1.y,trackPos2.x,trackPos2.y);
            buffer.textSize(12);
            buffer.text(Math.round(val),910,20);
            buffer.shape(design, pos.x,pos.y);
        }
    }

    public void onClick(float x, float y) {
            held = true;
        }
    public void onHold(float x, float y) {
        if (held) {
            PVector difference = vecSub(trackPos1,trackPos2);
            float norm = normalize(y,trackPos2.y,trackPos1.y);
            this.val = max(minVal,min(maxVal,((maxVal-minVal)*norm)+minVal));
            this.pos = new PVector(trackPos1.x-offsetx,max(trackPos1.y,min(trackPos2.y,y))-offsety);
            this.touch.move(pos);
        }
    }
    public void onRelease(float x, float y) {
        held = false;
    }
}

public class DeleteButton extends UIButton {
    public DeleteButton(PVector pos, PShape design, float height, float width, int textFill, float textSize, PVector textpos) {
        super(pos,design,height,width,"Delete",textFill,textSize,textpos);
    }
    public void onClick(float x, float y) {
        mode = editMode.DELETE;
        selected = null;
        selectedConn = null;
        selectedStar = null;
    }
    public void onHold(float x, float y) {}
    public void onRelease(float x, float y) {}
}
public class SelectButton extends UIButton {
    public SelectButton(PVector pos, PShape design, float height, float width, int textFill, float textSize, PVector textpos) {
        super(pos,design,height,width,"Select",textFill,textSize,textpos);
    }
    public void onClick(float x, float y) {
        mode = editMode.SELECT;
        selected = null;
        selectedConn = null;
        selectedStar = null;
    }
    public void onHold(float x, float y) {}
    public void onRelease(float x, float y) {}
}
public class AddButton extends UIButton {
    public AddButton(PVector pos, PShape design, float height, float width, int textFill, float textSize, PVector textpos) {
        super(pos,design,height,width,"Add",textFill,textSize,textpos);
    }
    public void onClick(float x, float y) {
        mode = editMode.ADD;
        selected = null;
        selectedConn = null;
        selectedStar = null;
    }
    public void onHold(float x, float y) {}
    public void onRelease(float x, float y) {}
}
public class ClearButton extends UIButton {
    public ClearButton(PVector pos, PShape design, float height, float width, int textFill, float textSize, PVector textpos) {
        super(pos,design,height,width,"Clear",textFill,textSize,textpos);
    }
    public void onClick(float x, float y) {
        selected = null;
        selectedConn = null;
        selectedStar = null;
        starmap.clear();
    }
    public void onHold(float x, float y) {}
    public void onRelease(float x, float y) {}
}
public class GenButton extends UIButton {
    public GenButton(PVector pos, PShape design, float height, float width, int textFill, float textSize, PVector textpos) {
        super(pos,design,height,width,"Generate",textFill,textSize,textpos);
    }
    public void onClick(float x, float y) {
        selected = null;
        selectedConn = null;
        selectedStar = null;
        starmap.clear();
        jmDraw.execute(() -> {prepareJumpmap();});
    }
    public void onHold(float x, float y) {}
    public void onRelease(float x, float y) {}
}


  public void settings() { size(1000, 1000); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "JumpmapGenerator" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
