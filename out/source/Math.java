/* autogenerated by Processing revision 1293 on 2024-03-03 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Math extends PApplet {

public float normalize(float val, float min, float max) {
    return (val - min)/(max - min);
}

public float distance(int x1, int x2, int y1, int y2) {
    int xd = x1 - x2;
    int yd = y1 - y2;
    float dist = (float) Math.sqrt(xd*xd + yd*yd);
    return dist;
}

public float clamp(float val, float min, float max) {
    float temp;
    if (val < min) {
        temp = min;
    } else if (val > max) {
        temp = max;
    } else {
        temp = val;
    }
    return temp;
}

public float shunt(float val, float min, float max) {
    float temp;
    if (val > min) {
        temp = max;
    } else {
        temp = min;
    }
    return temp;
}

public static boolean onSegment(PVector p, PVector q, PVector r) 
{ 
    if (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && 
        q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y)) 
    return true; 
  
    return false; 
} 
  
// To find orientation of ordered triplet (p, q, r). 
// The function returns following values 
// 0 --> p, q and r are collinear 
// 1 --> Clockwise 
// 2 --> Counterclockwise 
public static float orientation(PVector p, PVector q, PVector r) 
{ 
    // See https://www.geeksforgeeks.org/orientation-3-ordered-points/ 
    // for details of below formula. 
    float val = (q.y - p.y) * (r.x - q.x) - 
            (q.x - p.x) * (r.y - q.y); 
  
    if (val == 0) return 0; // collinear 
  
    return (val > 0)? 1: 2; // clock or counterclock wise 
} 
  
// The main function that returns true if line segment 'p1q1' 
// and 'p2q2' intersect. 
public static boolean doIntersect(PVector p1, PVector q1, PVector p2, PVector q2) 
{ 
    // Find the four orientations needed for general and 
    // special cases 
    float o1 = orientation(p1, q1, p2); 
    float o2 = orientation(p1, q1, q2); 
    float o3 = orientation(p2, q2, p1); 
    float o4 = orientation(p2, q2, q1); 
  
    // General case 
    if (o1 != o2 && o3 != o4) 
        return true; 
  
    // Special Cases 
    // p1, q1 and p2 are collinear and p2 lies on segment p1q1 
    if (o1 == 0 && onSegment(p1, p2, q1)) return true; 
  
    // p1, q1 and q2 are collinear and q2 lies on segment p1q1 
    if (o2 == 0 && onSegment(p1, q2, q1)) return true; 
  
    // p2, q2 and p1 are collinear and p1 lies on segment p2q2 
    if (o3 == 0 && onSegment(p2, p1, q2)) return true; 
  
    // p2, q2 and q1 are collinear and q1 lies on segment p2q2 
    if (o4 == 0 && onSegment(p2, q1, q2)) return true; 
  
    return false; // Doesn't fall in any of the above cases 
} 
class UStar {
    PVector pos;
    int radius;
    int col;
    List<UStar> neighbors;
    
    public UStar(int x, int y, int r, int col) {
        this.pos = new PVector(x,y);
        this.radius = r;
        this.col = col;
        neighbors = new ArrayList<UStar>();
    }
    public UStar() {
        this.pos = new PVector(0,0);
        this.radius = 0;
        this.col = color(0,0,0);
        neighbors = new ArrayList<UStar>();
    }

    public PVector pos() {
        return pos;
    }

    public int posX() {
        return (int) pos.x;
    }

    public int posY() {
        return (int) pos.y;
    }

    public int radius() {
        return radius;
    }

    public int col() {
        return col;
    }
    
    @Override
    public String toString() {
      return "[ x:"+pos.x+"y:"+pos.y+" rad:"+radius+"]";
    }
}

class Connection { 
    UStar pos1;
    UStar pos2;
    float dist;
    int col;

    public Connection(UStar p1, UStar p2, int col) {
        this.col = col;
        pos1 = p1;
        pos2 = p2;
        dist = distance(p1.posX(),p2.posX(),p1.posY(),p2.posY());
    }

    public UStar getFirstStar() {
        return pos1;
    } 
    public UStar getSecondStar() {
        return pos2;
    }

    public PVector getPos1() {
        PVector p1 = pos1.pos();
        PVector p2 = pos2.pos();
        float dx = p2.x-p1.x;
        float dy = p2.y-p1.y;
        float tv = abs(dx)+abs(dy);
        float radius = pos1.radius();
        float nx = normalize(dx,0,tv);
        float ny = normalize(dy,0,tv);
        PVector fin = new PVector(p1.x+nx,p1.y+ny);
        return fin;
    }
    public PVector getPos2() {
        PVector p1 = pos2.pos();
        PVector p2 = pos1.pos();
        float dx = p2.x-p1.x;
        float dy = p2.y-p1.y;
        float tv = abs(dx)+abs(dy);
        float radius = pos2.radius();
        float nx = normalize(dx,0,tv);
        float ny = normalize(dy,0,tv);
        PVector fin = new PVector(p1.x+nx,p1.y+ny);
        return fin;
    }
    public int col() {
        return col;
    }
    public float dist(){
        return dist;
    }
    public boolean match(UStar one, UStar two) {
        if (pos1 == one || pos2 == one) {
            if (pos1 == two || pos2 == two) {
                return true;
            }
        }
        return false;
    }
}

class StarMap {
    private List<UStar> starMap;
    private List<Connection> jump;

    public StarMap() {
        starMap = new ArrayList<UStar>();
        jump = new ArrayList<Connection>();
    }
    public StarMap(List<UStar> list) {
        starMap = list;
        jump = new ArrayList<Connection>();
    }
    public StarMap(List<UStar> list, List<Connection> conn) {
        starMap = list;
        jump = conn;
    }

    public UStar nearestNeighbor(int x, int y) {
        float closestDist = 99999999; //arbitrarily high, so its initialized, but always overwritten
        UStar neighbor = new UStar();
        for (int i = 0; i < starMap.size(); i++) {
            UStar ref = starMap.get(i);
            float dist = distance(x,ref.posX(),y,ref.posY());
            if (dist < closestDist) {
                closestDist = dist;
                neighbor = ref;
            }
        }
        return neighbor;
    }

    public List<UStar> nearestNeighbors(UStar star, float ammount, List<UStar> exclusion, float distanceLimit) {
        ArrayList<UStar> neighbor = new ArrayList<UStar>();
        for (int i = 0; i < starMap.size(); i++) {
            UStar ref = starMap.get(i);
            float dist = distance(star.posX(),ref.posX(),star.posY(),ref.posY());
            if (neighbor.size() == 0 && dist < distanceLimit) {
                if (!exclusion.contains(ref) && ref != star) {
                    neighbor.add(ref);
                }
            }
            for (int a = 0; a < neighbor.size(); a++) {
                UStar na = neighbor.get(a);
                float ndist = distance(star.posX(),na.posX(),star.posY(),na.posY());
                if (dist < ndist && dist < distanceLimit) {
                    if (!exclusion.contains(ref) && ref != star) {
                        if (neighbor.size() < ammount) {
                            neighbor.add(ref); 
                        } else {
                            UStar elim = new UStar();
                            float furDist = 0;
                            for (UStar n : neighbor) {
                                float fdist = distance(star.posX(),n.posX(),star.posY(),n.posY());
                                if (fdist > furDist) {
                                    furDist = fdist;
                                    elim = n;
                                }
                            }
                            neighbor.remove(elim);
                            neighbor.add(ref);
                        }
                    }
                }
            }
        }
        return neighbor;
    }
    public List<UStar> nearestNeighbors(UStar star, float ammount, List<UStar> exclusion) {
        return nearestNeighbors(star,ammount,exclusion,999999999);
    }
    public List<UStar> nearestNeighbors(UStar star, float ammount) {
        return nearestNeighbors(star,ammount,new ArrayList<UStar>());
    }
    public boolean jumpMatch(UStar one, UStar two) {
        for (Connection c : jump) {
            if (c.match(one,two)) {
                return true;
            }
        }
        return false;
    }
    public boolean checkIntersect(Connection one, Connection two) {
        PVector A = one.getPos1();
        PVector B = one.getPos2();
        PVector C = two.getPos1();
        PVector D = two.getPos2();
      return doIntersect(A,B,C,D);
    }

    public void addConnection(UStar one, UStar two) {
        addConnection(one, two, color(255));
    }
    public void addConnection(UStar one, UStar two, int col) {
        if (!jumpMatch(one,two)) {
            jump.add(new Connection(one, two, col));
        }
    }
    public void removeConnection(Connection c) {
        jump.remove(c);
    }

    public List<Connection> getJumpLanes() {
        return jump;
    }

    public void add(UStar star) {
        starMap.add(star);
    }

    public int size() {
        return starMap.size();
    }

    public UStar retrieve(int index) {
        return starMap.get(index);
    }
}
public class UImanager {
    private List<UIBody> components;

    public void render() {

    }

    public registerClick(float x, float y) {
        for (UIBody ui : components) {
            if (ui.inBounds(x,y)) {
                ui.onClick();
            }
        }
    }
}

public class Touchbox {
    public PVector pos;
    public PVector limit;
    private PVector difference;

    public Touchbox(PVector pos, PVector limit) {
        this.pos = pos;
        this.limit = limit;
        difference = limit-pos;
    }

    public void move(PVector newpos) {
        pos = newpos;
        limit = newpos+difference;
    }

    public boolean touched(float x, float y) {
        if (x>pos.x && x<limit.x && y>pos.y && y<pos.y) {
            return true;
        }
        return false;
    }
}

public class UIBody {
    private PVector pos;
    private PShape design;
    private Touchbox touch;
    private Runnable click;
    private Runnable hold;
    private Runnable release;


    public UIBody(PVector pos, PShape design, Touchbox touch) {
        this.pos = pos;
        this.design = design;
        this.touch = touch;
    }
    public UIBody(PVector pos, PShape design, Touchbox touch, Runnable click, Runnable hold, Runnable release) {
        this.pos = pos;
        this.design = design;
        this.touch = touch;
        this.click = click;
        this.hold = hold;
        this.release = release;
    }

    public void onClick() {

    }
    public void onHold() {

    }
    public void onRelease() {

    }
    public boolean inBounds(float x, float y) {
        touch.touched(x,y);
    }

    public void render() {

    }
    public void render(PGraphics buffer) {
        
    }
}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Math" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
